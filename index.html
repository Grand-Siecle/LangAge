<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangAge</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 min-h-screen p-6">
    <div class="max-w-4xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-slate-800 mb-2">LangAge</h1>
            <p class="text-slate-600">Convertissez vos fichiers ALTO en texte normalisé</p>
        </header>

        <div class="bg-white rounded-xl shadow-lg p-8 mb-6">
            <div id="dropZone" class="border-3 border-dashed border-slate-300 rounded-lg p-12 text-center transition-all hover:border-blue-400 hover:bg-blue-50 cursor-pointer">
                <svg class="mx-auto h-16 w-16 text-slate-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                </svg>
                <p class="text-lg text-slate-700 mb-2">Glissez-déposez vos fichiers ZIP ici</p>
                <p class="text-sm text-slate-500 mb-4">ou cliquez pour sélectionner</p>
                <input type="file" id="fileInput" accept=".zip" multiple class="hidden">
                <button onclick="document.getElementById('fileInput').click()" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors">
                    Sélectionner des fichiers
                </button>
            </div>

            <div id="fileList" class="mt-6 space-y-2"></div>

            <div id="settingsSection" class="hidden mt-8 pt-6 border-t border-slate-200">
                <div class="mb-6">
                    <div class="flex items-center justify-between mb-2">
                        <label class="text-sm font-medium text-slate-700">Paramètre de clustering (ε)</label>
                        <div class="flex items-center">
                            <span id="epsValue" class="text-sm font-semibold text-blue-600 mr-2">1.5</span>
                            <button id="helpButton" class="text-slate-400 hover:text-slate-600 transition-colors">
                                <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <input type="range" id="epsSlider" min="0.5" max="3.0" step="0.1" value="1.5" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    <div class="flex justify-between text-xs text-slate-500 mt-1">
                        <span>0.5 (Strict)</span>
                        <span>3.0 (Permissif)</span>
                    </div>
                    
                    <div id="helpText" class="hidden mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg text-sm text-slate-700">
                        <p class="font-medium mb-1">Qu'est-ce que le paramètre ε ?</p>
                        <p>Ce paramètre contrôle la détection des paragraphes. Une <strong>valeur basse</strong> (0.5-1.0) crée plus de paragraphes distincts, idéal pour les textes avec des retraits marqués. Une <strong>valeur élevée</strong> (2.0-3.0) regroupe plus de lignes ensemble, adapté aux textes sans retrait clair.</p>
                        <p class="mt-2"><strong>Conseil :</strong> Commencez avec 1.5 (défaut) et ajustez selon le résultat.</p>
                    </div>
                </div>

                <button id="startButton" class="w-full bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-colors font-medium text-lg shadow-md hover:shadow-lg">
                    Démarrer le traitement
                </button>
            </div>
        </div>

        <div id="progress" class="hidden bg-white rounded-xl shadow-lg p-6 mb-6">
            <div class="flex items-center justify-between mb-2">
                <span class="text-sm font-medium text-slate-700">Traitement en cours...</span>
                <span id="progressText" class="text-sm text-slate-600">0%</span>
            </div>
            <div class="w-full bg-slate-200 rounded-full h-2">
                <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>

        <div id="results" class="space-y-4"></div>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const settingsSection = document.getElementById('settingsSection');
        const epsSlider = document.getElementById('epsSlider');
        const epsValue = document.getElementById('epsValue');
        const helpButton = document.getElementById('helpButton');
        const helpText = document.getElementById('helpText');
        const startButton = document.getElementById('startButton');
        const progress = document.getElementById('progress');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const results = document.getElementById('results');
        let files = [];
        let processedFiles = {};

        dropZone.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                fileInput.click();
            }
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('border-blue-500', 'bg-blue-50');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('border-blue-500', 'bg-blue-50');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-blue-500', 'bg-blue-50');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        epsSlider.addEventListener('input', (e) => {
            epsValue.textContent = e.target.value;
        });

        helpButton.addEventListener('click', (e) => {
            e.preventDefault();
            helpText.classList.toggle('hidden');
        });

        startButton.addEventListener('click', () => {
            processFiles();
        });

        function handleFiles(newFiles) {
            files = Array.from(newFiles).filter(f => f.name.endsWith('.zip'));
            
            if (files.length === 0) {
                alert('Aucun fichier ZIP valide détecté. Veuillez sélectionner des fichiers .zip');
                return;
            }
            
            processedFiles = {};
            displayFileList();
            settingsSection.classList.remove('hidden');
            results.innerHTML = '';
        }

        function displayFileList() {
            fileList.innerHTML = files.map((f, i) => {
                const sizeKB = (f.size / 1024).toFixed(1);
                return `
                    <div class="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                        <div class="flex items-center">
                            <svg class="h-5 w-5 text-blue-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"/>
                            </svg>
                            <span class="text-sm text-slate-700">${f.name}</span>
                        </div>
                        <span class="text-xs text-slate-500">${sizeKB} KB</span>
                    </div>
                `;
            }).join('');
        }

        async function processFiles() {
            if (files.length === 0) {
                console.log('Aucun fichier à traiter');
                return;
            }
            
            const epsParam = parseFloat(epsSlider.value);
            startButton.disabled = true;
            startButton.classList.add('opacity-50', 'cursor-not-allowed');
            progress.classList.remove('hidden');
            results.innerHTML = '';

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const percent = ((i / files.length) * 100).toFixed(0);
                progressBar.style.width = percent + '%';
                progressText.textContent = percent + '%';

                try {
                    const text = await processZip(file, epsParam);
                    const filename = file.name.replace('.zip', '.txt');
                    processedFiles[filename] = text;
                    addResult(filename, true);
                } catch (error) {
                    console.error('Erreur:', error);
                    addResult(file.name, false, error.message);
                }
            }

            progressBar.style.width = '100%';
            progressText.textContent = '100%';
            setTimeout(() => {
                progress.classList.add('hidden');
                startButton.disabled = false;
                startButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }, 1000);
        }

        async function processZip(file, epsParam) {
            const zip = await JSZip.loadAsync(file);
            let allText = '';

            for (const [filename, zipEntry] of Object.entries(zip.files)) {
                if (filename.endsWith('.xml') && !zipEntry.dir) {
                    const content = await zipEntry.async('text');
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(content, 'text/xml');
                    const pageText = extractTextFromAlto(xmlDoc, epsParam);
                    allText += pageText + '\n' + '-'.repeat(80) + '\n\n';
                }
            }

            return allText;
        }

        function extractTextFromAlto(xmlDoc, epsParam) {
            const tags = xmlDoc.getElementsByTagName('Tags')[0];
            const tagMap = buildTagMap(tags);
            
            const textBlocks = Array.from(xmlDoc.getElementsByTagName('TextBlock'));
            
            const blocksData = textBlocks.map(block => ({
                element: block,
                type: getBlockType(block, tagMap),
                bbox: getBBox(block),
                vpos: parseFloat(block.getAttribute('VPOS') || 0)
            }));

            detectNestedZones(blocksData);
            const orderedBlocks = reorderBlocks(blocksData);

            let pageText = '';

            for (let blockData of orderedBlocks) {
                const block = blockData.element;
                const blockType = blockData.type;
                const textLines = Array.from(block.getElementsByTagName('TextLine'));
                
                const linesData = textLines.map(line => ({
                    element: line,
                    hpos: parseFloat(line.getAttribute('HPOS') || 0),
                    vpos: parseFloat(line.getAttribute('VPOS') || 0)
                }));

                linesData.sort((a, b) => a.vpos - b.vpos);

                if (blockType === 'CustomZone') {
                    for (let lineData of linesData) {
                        const lineText = extractLineText(lineData.element);
                        if (lineText.trim()) {
                            pageText += lineText + '\n';
                        }
                    }
                    pageText += '\n';
                } else {
                    const hposValues = linesData.map(l => l.hpos).sort((a, b) => a - b);
                    const q1 = percentile(hposValues, 25);

                    const positions = linesData.map(line => [
                        line.hpos < q1 ? q1 : line.hpos,
                        line.vpos
                    ]);

                    const scaler = createStandardScaler(positions);
                    const scaled = scaler ? scaler.transform(positions) : positions;
                    const labels = dbscan(scaled, epsParam, 1);

                    let paraText = '';
                    let prevLine = '';
                    let prevClusterId = labels[0];

                    for (let i = 0; i < linesData.length; i++) {
                        const lineData = linesData[i];
                        const lineText = extractLineText(lineData.element);
                        const currentClusterId = labels[i];

                        if (currentClusterId !== prevClusterId) {
                            if (paraText.trim()) {
                                pageText += paraText + '\n\n';
                            }
                            paraText = lineText;
                            prevLine = lineText;
                        } else {
                            if (prevLine.endsWith('-') || prevLine.endsWith('¬')) {
                                paraText += lineText;
                            } else if (prevLine) {
                                paraText += ' ' + lineText;
                            } else {
                                paraText = lineText;
                            }
                            prevLine = lineText;
                        }

                        prevClusterId = currentClusterId;
                    }

                    if (paraText.trim()) {
                        pageText += paraText + '\n\n';
                    }
                }
            }

            return pageText;
        }

        function getBBox(block) {
            return {
                x: parseFloat(block.getAttribute('HPOS') || 0),
                y: parseFloat(block.getAttribute('VPOS') || 0),
                width: parseFloat(block.getAttribute('WIDTH') || 0),
                height: parseFloat(block.getAttribute('HEIGHT') || 0)
            };
        }

        function calculateOverlap(bbox1, bbox2) {
            const x1 = Math.max(bbox1.x, bbox2.x);
            const y1 = Math.max(bbox1.y, bbox2.y);
            const x2 = Math.min(bbox1.x + bbox1.width, bbox2.x + bbox2.width);
            const y2 = Math.min(bbox1.y + bbox1.height, bbox2.y + bbox2.height);

            if (x2 < x1 || y2 < y1) return 0;

            const overlapArea = (x2 - x1) * (y2 - y1);
            const bbox1Area = bbox1.width * bbox1.height;

            return bbox1Area > 0 ? overlapArea / bbox1Area : 0;
        }

        function detectNestedZones(blocksData) {
            for (let i = 0; i < blocksData.length; i++) {
                const block = blocksData[i];
                
                for (let j = 0; j < blocksData.length; j++) {
                    if (i === j) continue;
                    
                    const otherBlock = blocksData[j];
                    const overlap = calculateOverlap(block.bbox, otherBlock.bbox);

                    if (overlap >= 0.8) {
                        block.parentZone = otherBlock.type;
                        block.parentIndex = j;
                        break;
                    }
                }
            }
        }

        function reorderBlocks(blocksData) {
            const runningTitle = [];
            const numbering = [];
            const quireMarks = [];
            const normal = [];

            for (let block of blocksData) {
                if (block.type === 'QuireMarksZone') {
                    quireMarks.push(block);
                } else if (block.type === 'RunningTitleZone' && block.parentZone !== 'MainZone') {
                    runningTitle.push(block);
                } else if (block.type === 'NumberingZone' && block.parentZone !== 'MainZone') {
                    numbering.push(block);
                } else {
                    normal.push(block);
                }
            }

            runningTitle.sort((a, b) => a.vpos - b.vpos);
            numbering.sort((a, b) => a.vpos - b.vpos);
            quireMarks.sort((a, b) => a.vpos - b.vpos);

            return [...runningTitle, ...numbering, ...normal, ...quireMarks];
        }

        function buildTagMap(tagsElement) {
            const tagMap = {};
            if (!tagsElement) return tagMap;
            
            const otherTags = tagsElement.getElementsByTagName('OtherTag');
            for (let tag of otherTags) {
                const id = tag.getAttribute('ID');
                const label = tag.getAttribute('LABEL');
                if (id && label) {
                    tagMap[id] = label;
                }
            }
            return tagMap;
        }

        function getBlockType(block, tagMap) {
            const tagrefs = block.getAttribute('TAGREFS');
            if (!tagrefs) return 'DefaultZone';
            
            const tagIds = tagrefs.split(' ');
            for (let tagId of tagIds) {
                const label = tagMap[tagId];
                if (label && label.endsWith('Zone')) {
                    return label;
                }
            }
            return 'DefaultZone';
        }

        function detectLanguage(text) {
            if (!text || text.length < 5) return 'fr'; // Très court = français par défaut
            
            const normalized = text.toLowerCase();
            
            // === MOTS LATINS COURANTS ===
            const latinWords = [
                // Conjonctions et particules
                'et', 'sed', 'aut', 'nam', 'enim', 'autem', 'atque', 'ac', 'neque', 'nec',
                'vel', 'an', 'ergo', 'igitur', 'itaque', 'tamen', 'quoque', 'quidem',
                // Pronoms et démonstratifs
                'qui', 'quae', 'quod', 'quis', 'quid', 'hic', 'haec', 'hoc', 'ille', 'illa',
                'illud', 'iste', 'ista', 'istud', 'is', 'ea', 'id', 'ipse', 'ipsa', 'ipsum',
                // Prépositions
                'cum', 'in', 'ex', 'ab', 'ad', 'de', 'per', 'pro', 'sine', 'inter', 'post',
                'ante', 'sub', 'super', 'apud', 'contra', 'circa', 'propter',
                // Verbes courants
                'est', 'sunt', 'esse', 'erat', 'erant', 'fuit', 'fuerunt', 'sit', 'sint',
                'potest', 'possunt', 'posse', 'possum', 'debet', 'debent', 'vult', 'volunt',
                'facit', 'faciunt', 'facere', 'fecit', 'dicit', 'dicunt', 'dixit', 'habet',
                'habent', 'habere', 'venit', 'veniunt', 'dat', 'dant', 'dare',
                // Adverbes
                'non', 'ne', 'sic', 'ita', 'tam', 'modo', 'nunc', 'tunc', 'semper', 'numquam',
                'etiam', 'quoque', 'vero', 'autem', 'enim', 'igitur', 'ergo', 'valde',
                // Autres mots courants
                'res', 'rei', 'rem', 'homo', 'hominis', 'deus', 'dei', 'deo', 'deum',
                'animus', 'corpus', 'tempus', 'locus', 'vita', 'mors', 'bellum', 'pax'
            ];
            
            // === MOTS FRANÇAIS COURANTS ===
            const frenchWords = [
                // Articles
                'le', 'la', 'les', 'un', 'une', 'des', 'du', 'au', 'aux',
                // Prépositions
                'de', 'à', 'dans', 'pour', 'par', 'sur', 'avec', 'sans', 'sous', 'vers',
                'chez', 'contre', 'entre', 'parmi', 'selon', 'durant', 'pendant',
                // Pronoms
                'je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles', 'on',
                'me', 'te', 'se', 'lui', 'leur', 'qui', 'que', 'quoi', 'dont', 'où',
                'ce', 'cet', 'cette', 'ces', 'mon', 'ton', 'son', 'ma', 'ta', 'sa',
                'mes', 'tes', 'ses', 'notre', 'votre', 'leur', 'nos', 'vos', 'leurs',
                // Conjonctions
                'et', 'ou', 'mais', 'donc', 'or', 'ni', 'car', 'que', 'si', 'comme',
                'quand', 'lorsque', 'puisque', 'quoique', 'afin', 'tandis',
                // Verbes auxiliaires et courants
                'est', 'sont', 'être', 'était', 'étaient', 'été', 'sera', 'seront',
                'ai', 'as', 'a', 'avons', 'avez', 'ont', 'avoir', 'avait', 'avaient', 'eu',
                'fait', 'font', 'faire', 'faisait', 'peut', 'peuvent', 'pouvoir', 'pouvait',
                'doit', 'doivent', 'devoir', 'veut', 'vouloir', 'dit', 'disent', 'dire',
                // Adverbes
                'ne', 'pas', 'plus', 'très', 'bien', 'mal', 'aussi', 'encore', 'déjà',
                'toujours', 'jamais', 'souvent', 'parfois', 'beaucoup', 'peu', 'trop',
                'assez', 'tant', 'autant', 'ainsi', 'alors', 'donc', 'puis',
                // Autres mots courants
                'chose', 'point', 'homme', 'femme', 'jour', 'temps', 'monde', 'vie',
                'mort', 'dieu', 'roi', 'peuple', 'terre', 'ciel'
            ];
            
            // === TERMINAISONS TYPIQUES LATINES ===
            const latinEndings = [
                /\w+us\b/, /\w+um\b/, /\w+am\b/, /\w+em\b/, /\w+im\b/,
                /\w+ae\b/, /\w+is\b/, /\w+ibus\b/, /\w+arum\b/, /\w+orum\b/,
                /\w+atur\b/, /\w+antur\b/, /\w+etur\b/, /\w+untur\b/
            ];
            
            // === TERMINAISONS TYPIQUES FRANÇAISES ===
            const frenchEndings = [
                /\w+tion\b/, /\w+ment\b/, /\w+eur\b/, /\w+euse\b/, /\w+ité\b/,
                /\w+ance\b/, /\w+ence\b/, /\w+isme\b/, /\w+esse\b/
            ];
            
            let latinScore = 0;
            let frenchScore = 0;
            
            // Compter les mots latins
            latinWords.forEach(word => {
                const regex = new RegExp('\\b' + word + '\\b', 'g');
                const matches = normalized.match(regex);
                if (matches) latinScore += matches.length;
            });
            
            // Compter les mots français
            frenchWords.forEach(word => {
                const regex = new RegExp('\\b' + word + '\\b', 'g');
                const matches = normalized.match(regex);
                if (matches) frenchScore += matches.length;
            });
            
            // Bonus pour les terminaisons typiques (poids plus faible)
            latinEndings.forEach(pattern => {
                const matches = normalized.match(pattern);
                if (matches) latinScore += matches.length * 0.3;
            });
            
            frenchEndings.forEach(pattern => {
                const matches = normalized.match(pattern);
                if (matches) frenchScore += matches.length * 0.3;
            });
                    
            // Si score latin nettement supérieur (30% de plus)
            return latinScore > frenchScore * 1.3 ? 'la' : 'fr';
        }

        function extractLineText(lineElement) {
            const strings = lineElement.getElementsByTagName('String');
            let lineText = '';

            for (let str of strings) {
                let content = str.getAttribute('CONTENT') || '';
                const subs = str.getAttribute('SUBS_CONTENT');
                
                const language = detectLanguage(content);
                console.log("language : " + language)
                content = normalizeText(content, subs, language);
                lineText += content + ' ';
            }

            return lineText.trim();
        }

        function percentile(arr, p) {
            if (arr.length === 0) return 0;
            const index = (p / 100) * (arr.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index % 1;
            return arr[lower] * (1 - weight) + arr[upper] * weight;
        }

        function createStandardScaler(points) {
            if (points.length === 0) return null;
            
            const dims = points[0].length;
            const means = [];
            const stds = [];

            for (let d = 0; d < dims; d++) {
                const values = points.map(p => p[d]);
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const std = Math.sqrt(variance) || 1;
                means.push(mean);
                stds.push(std);
            }

            return {
                means: means,
                stds: stds,
                transform: function(points) {
                    return points.map(point =>
                        point.map((val, d) => (val - means[d]) / stds[d])
                    );
                },
                inverseTransform: function(points) {
                    return points.map(point =>
                        point.map((val, d) => val * stds[d] + means[d])
                    );
                }
            };
        }

        function dbscan(points, eps, minSamples) {
            const n = points.length;
            const labels = new Array(n).fill(-1);
            let clusterId = 0;

            function distance(p1, p2) {
                return Math.sqrt(p1.reduce((sum, val, i) => sum + Math.pow(val - p2[i], 2), 0));
            }

            function getNeighbors(pointIdx) {
                const neighbors = [];
                for (let i = 0; i < n; i++) {
                    if (i !== pointIdx && distance(points[pointIdx], points[i]) <= eps) {
                        neighbors.push(i);
                    }
                }
                return neighbors;
            }

            function expandCluster(pointIdx, neighbors, clusterId) {
                labels[pointIdx] = clusterId;
                const queue = [...neighbors];

                while (queue.length > 0) {
                    const currentIdx = queue.shift();

                    if (labels[currentIdx] === -1) {
                        labels[currentIdx] = clusterId;
                        const currentNeighbors = getNeighbors(currentIdx);

                        if (currentNeighbors.length >= minSamples) {
                            queue.push(...currentNeighbors);
                        }
                    }
                }
            }

            for (let i = 0; i < n; i++) {
                if (labels[i] !== -1) continue;

                const neighbors = getNeighbors(i);

                if (neighbors.length < minSamples) {
                    continue;
                } else {
                    expandCluster(i, neighbors, clusterId);
                    clusterId++;
                }
            }

            return labels;
        }

        function normalizeText(text, subs, language = 'fr') {
            if (!text) return "";

            text = text.normalize('NFD');

            // --- Normalisations simples ---
            text = text
                .replace(/ſ/g, 's')   // s long
                .replace(/'/g, '’');  // apostrophe typographique

            // --- Abréviations médiévales ---
            text = text
                .replace(/ꝰ/g, 'ꝰ[us]')
                .replace(/q;/g, 'q;[que]');

            // --- Traitement universel des tildes (combining tilde U+0303) ---
            text = text.replace(/([a-z])\u0303/gi, (match, letter, offset, string) => {
                        const nextChar = string[offset + match.length] || '';
                        let expansion;
                        
                        if (language === 'la') {
                            // Latin : par défaut 'm'
                            expansion = 'm';
                        } else {
                            // Français : 'n' par défaut, 'm' devant b/m/p
                            expansion = (nextChar && 'bmp'.includes(nextChar.toLowerCase())) ? 'm' : 'n';
                        }

                        return letter + '\u0303[' + expansion + ']';
                    });

            // --- Re-normalisation en NFC (forme composée) pour l'affichage ---
            text = text.normalize('NFC');

            // --- Ajout facultatif du subs ---
            if (subs && subs !== text && text.includes('[')) {
                text += `[${subs}]`;
            }

            // --- Typographie française ---
            text = text.replace(/\s*([;:?!])/g, '\u00A0$1');

            return text;
        }


        function downloadText(text, filename) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function addResult(filename, success, error = '') {
            const div = document.createElement('div');
            const bgClass = success ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200';
            const iconColor = success ? 'text-green-600' : 'text-red-600';
            const textColor = success ? 'text-green-800' : 'text-red-800';
            const iconPath = success 
                ? 'M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z'
                : 'M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z';
            const message = success ? 'Traité : ' : 'Erreur : ';
            
            div.className = 'p-4 rounded-lg ' + bgClass;
            
            let html = '<div class="flex items-center justify-between">';
            html += '<div class="flex items-center">';
            html += '<svg class="h-5 w-5 ' + iconColor + ' mr-2 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">';
            html += '<path fill-rule="evenodd" d="' + iconPath + '" clip-rule="evenodd"/>';
            html += '</svg>';
            html += '<span class="text-sm font-medium ' + textColor + '">' + message + filename + '</span>';
            html += '</div>';
            
            if (success) {
                html += '<button onclick="downloadFile(\'' + filename + '\')" class="ml-4 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors text-sm font-medium flex items-center whitespace-nowrap">';
                html += '<svg class="h-4 w-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">';
                html += '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>';
                html += '</svg>';
                html += 'Télécharger';
                html += '</button>';
            }
            
            html += '</div>';
            
            if (error) {
                html += '<p class="text-xs text-red-600 mt-2 ml-7">' + error + '</p>';
            }
            
            div.innerHTML = html;
            results.appendChild(div);
        }

        function downloadFile(filename) {
            const text = processedFiles[filename];
            if (text) {
                downloadText(text, filename);
            }
        }
    </script>
</body>
</html>
